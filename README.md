# Return-to-Work-2026
day7:
捡起java的第一天，配置环境及堆栈算法的尝试
其实有些困难攻克了就不是困难，一切难题也是有迹可循的。就像寻找可用括号，没有接触过这道题的时候，我会感觉好难，为什么面试官会考这么难的题，但是这道题其实并不难，难的是没有接触过而产生的恐惧心理。

day6:
今天看了之前的开发代码，发现了一些容易发现的bug。例如：
如果 Redis 服务宕机或网络抖动，系统会默认验证码校验通过。攻击者可以通过压测手段使 Redis 响应变慢或直接针对 Redis 进行攻击，从而轻松绕过验证码进行暴力破解。对应解释“我不仅指出了代码中 catch 块直接返回 ok 的逻辑缺陷，还通过编写 Mockito 单元测试 模拟了 Redis 宕机的场景，当场证明了在这种极端情况下，系统确实会产生安全漏洞。

虽然 LoginUserDTO 手写了 toString() 并排除了 password 字段，但这种做法非常依赖开发者的自觉。一旦有人重新生成了 Lombok 的 @ToString 或者使用了 ReflectionToStringBuilder，用户的明文密码就会被记录到日志文件中，违反合规要求。

DEFAULT_IMAGE_EXPIRE = 120 和返回的字符串（如 "appKey can not be null"）可以进一步常量化或国际化。
day5:
大体上完成了今天的任务，但是有一个小问题是国内和国外访问同一个网站也会有不同的ui展示，例如bing.com我直接google搜索，上面是有搜索框的，但是代码调用的时候没有搜索框.

简历可用内容：
基于 Playwright + TypeScript 搭建了企业级 UI 自动化测试框架，引入 POM (Page Object Model) 设计模式，将页面元素与业务逻辑解耦，代码复用率提升约 40%。

针对复杂业务场景实现 DDT (Data-Driven Testing)，通过外部 JSON 配置驱动多组测试数据，大幅提升了回归测试的覆盖率。

设计了 StorageState 鉴权复用方案，通过 API 预注入 Token 绕过重复登录逻辑，将单条用例执行耗时缩短 60% 以上。

具备处理复杂环境下 UI 不一致性（如多地区 UI 差异） 的实战经验，通过定位器优化与环境标准化配置提升了脚本的稳定性（Flaky Rate 降低）。


day4:
数据驱动测试
今天尝试在必应里面做了多组数据驱动的查询，以及页面数据的对比。遇到了很多问题，比如输入框里面查不到fill的内容以及弹窗二次确认的问题。
对ai可以的态度，仍然保持他可以给你解决一些问题，但是你心里还是要有1,2,3.不然你会被他牵着鼻子走。很难找到问题的正确解决方案。

day3:
今天完成登录态捕获 -> 本地持久化 -> 测试上下文注入的全流程，对于自动登录有了新的理解和认识。
[ √] 协议复习： 能够口述 GET、POST、PUT、DELETE 的区别，以及 401 和 403 报错意味着什么。

[ √] Apifox 实战： 成功在工具里调通一个带参数的 POST 请求。

[ √] 脚本产出： 成功运行一个 Playwright 的接口测试脚本，并在终端看到绿色通过。

[ √] 数据校验： 尝试在脚本中加入对返回 JSON 结构的断言（比如：验证 id 必须是数字）。


day2:
[ √] 移动端录制： 成功使用 codegen 模拟手机环境并生成脚本。

[ √] 全链路分析： 能够熟练操作 Trace Viewer 查看网络请求和页面快照。

[√ ] AI 辅助提效： 完成至少一次由 AI 辅助的代码重构或断言编写。

[ √] 文档沉淀： 在 GitHub 的 README.md 中记录：“相比 Selenium，Playwright 的 Tracing 功能对排障效率提升了多少？”
可以快速的定位问题，每一步的截图和请求直观展示，并且录制功能也是很容易上手。
[√] 手动拆分：成功将“元素定位”与“测试逻辑”分离开。

[ √] 手敲代码：核心的 locator 和 action 是自己敲出来的，而不是 Copilot 生成的。

[√] 报错调试：在重构过程中，如果因为 module.exports 或路径问题报错，是否能看懂报错并修复？

[ √] 运行成功：重构后的代码能像昨天一样跑通。

day1:
[ √] 拥有了一个整洁的独立工位。

[ √] 终端环境配置完成，看起来像个极客。

[ √] 成功运行了一个 Docker 容器。

[√ ] 在 GitHub 上创建了回归仓库，并提交了第一次 Commit。

[√ ] 写出了一个能跑通的 Playwright 脚本。

